+function ($) {
  'use strict';

  /**
   * Define our global var.
   */
  window.cruk_base = {};
  cruk_base.is_touch_device = 'ontouchstart' in document.documentElement;

  /**
   * Forms!
   */

  /**
   * Simulate focus for input groups.
   */
  $('.cr-input-group__input').on('focus', function(){
    $(this).parent().addClass('cr-input-group--focused');
  }).on('blur', function(){
    $(this).parent().removeClass('cr-input-group--focused');
  });

}(jQuery);;jQuery( document ).ready(function( $ ) {
    'use strict';
    // First, apply to any pre-checked options
    $('form').find('input[type=radio]:checked, input[type=checkbox]:checked').each(function() {
        checkIt($(this));
    });

    // Now set up listeners to ensure that any changes are also checked
    $('form').on('change', 'input[type=radio], input[type=checkbox]', function() {
        checkIt($(this));
    });

    // For a given jQuery input object, ensure that it's checked
    function checkIt($input) {
        var type = $input.attr('type');
        if (type === 'radio') {
            checkItRadio($input);
        } else if (type === 'checkbox') {
            checkItCheckbox($input);
        }
    }

    function checkItRadio($input) {
        // Turn off all styling for this radio group

        var name = $input.attr('name');
        var id = $input.attr('id');
        $('input[name=' + name + ']').not('#' + id).parents('.radio').removeClass('radio-selected');

        // Now apply it to the current one
        $input.parents('.radio').addClass('radio-selected');
    }

    function checkItCheckbox($input) {
        if ($input.is(':checked')) {
            $input.parents('.checkbox').addClass('checkbox-selected');
        } else {
            $input.parents('.checkbox').removeClass('checkbox-selected');
        }
    }
});
;+function ($) {
  'use strict';

  /**
   * Search combined in place class.
   */
  var SearchCIP = function (element, options) {
    this.$element    = $(element)
    this.$form       = this.$element.closest('form')
    this.$input      = this.$element.find('.cr-search-input__input')
    this.$icon       = this.$element.find('.cr-input-group__icon')
    this.options     = options
    // Store the last search value.
    this.last_search = null
    // Has a search been submitted?
    this.active      = false
    // Store the aria label value for the submit button.
    this.submit_aria_label = this.$element.find('button').attr('aria-label');

    /**
     * Bind the events.
     */
    this.$form.on('submit', $.proxy(this.submitHandler, this))
    this.$input.on('input', $.proxy(this.inputChange, this))
    this.$icon.on('click', $.proxy(this.iconClick, this))
  }

  SearchCIP.VERSION  = '0.0.1'

  SearchCIP.DEFAULTS = {
    // Boolean. Force touch behaviour to be active on non-touch devices.
    force_touch_device: false
  }

  /**
   * Determine if the string passed in would consistute a new search if
   * submitted.
   *
   * @param  {String}  input_value - The string to check against the last search.
   * @return {Boolean}
   */
  SearchCIP.prototype.isNewSearch = function(input_value) {
    if (this.active && input_value !== '' && input_value !== this.last_search) {
      // Invalidate the current active search.
      this.active = false

      return true
    }

    return false
  }

  /**
   * Change the icons within the combined search field, only happens on touch
   * devices or when touch device behaviour is being forced.
   */
  SearchCIP.prototype.switchIcons = function() {
    var input_value = this.$input.val().trim()

    /**
     * Restore the magnifying glass icon as either:
     * 1. The field is blank
     * 2. The input doesn't match the previous search
     */
    if ((input_value === '' || this.isNewSearch(input_value)) && this.$icon.hasClass('glyphicon-remove')) {
      var button_aria_label = this.submit_aria_label
      this.$icon.fadeOut('fast', function(){
        $(this).removeClass('glyphicon-remove').addClass('glyphicon-search').fadeIn('fast').parent().attr('aria-label', button_aria_label)
      })
    }

    /**
     * A valid search is being done but we've still got the search icon in
     * place so switch it for an 'x'.
     */
    if (this.active && this.$icon.hasClass('glyphicon-search')) {
      this.$icon.fadeOut('fast', function(){
        $(this).removeClass('glyphicon-search').addClass('glyphicon-remove').fadeIn('fast').parent().attr('aria-label', 'Clear your current search')
      })
    }
  }

  /**
   * React to the icon within the combined search field when it is clicked. On
   * touch devices it will clear the current search field value and re-focus to
   * the textfield input.
   */
  SearchCIP.prototype.iconClick = function() {
    if (this.$icon.hasClass('glyphicon-remove')) {
      this.last_search = null
      this.active = false
      this.$input.val('').focus()
      this.switchIcons()
      this.$element.trigger('search_cip:search_cleared')
    }
  }

  /**
   * React to the value within the textfield changing, if on a touch device
   * this is when we'd switch to the icon.
   */
  SearchCIP.prototype.inputChange = function() {
    var input_value = this.$input.val()

    if ((cruk_base.is_touch_device || this.options.force_touch_device)) {
      this.switchIcons()
    }
  }

  /**
   * Submit handler for the form.
   */
  SearchCIP.prototype.submitHandler = function (e) {
    e.preventDefault()
    var input_value = this.$input.val().trim()

    if (input_value === '' || this.last_search !== '' && this.last_search === input_value) {
      return false
    }

    this.last_search = input_value
    this.active = true
    this.$element.trigger('search_cip:search_execute', input_value)

    if (cruk_base.is_touch_device || this.options.force_touch_device) {
      this.switchIcons()
    }
  }

  /**
   * Plugin definition.
   */
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('cruk.search_cip')
      var options = $.extend({}, SearchCIP.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('cruk.search_cip', (data = new SearchCIP(this, options)))
    })
  }

  var old = $.fn.search_cip

  $.fn.search_cip             = Plugin
  $.fn.search_cip.Constructor = SearchCIP

  /**
   * Pass the plugin to no conflict.
   */
  $.fn.search_cip.noConflict = function () {
    $.fn.search_cip = old
    return this
  }

  /**
   * Apply our plugin to any elements that want it!
   */
  $(window).on('load', function () {
    $('[data-search-field="combined-ip"]').each(function () {
      var $search_cip = $(this)
      Plugin.call($search_cip, $search_cip.data())
    })
  })

}(jQuery);;jQuery( document ).ready(function( $ ) {
  'use strict';

  /*
   * This script is for demonstration purposes only. Pagination is typically handled by backend.
   * If you wish to use JS to handle pagination, take note that this is not intended for use on production sites.
   */

  /**
   * Pagination constructor.
   * @param {jQuery} element
   *   Element to paginate.
   * @param {object} [options]
   * @param {int} [options.maximumRange=2]
   *   The maximum range of a nearby item. Items at this range will be hidden on smaller devices.
   * @param {int} [options.minimumRange=1]
   *   The minimum range of a nearby item.
   *
   * @constructor
   */
  var Pagination = function (element, options) {
    var self = this;
    this.$element = $(element);
    this.$firstEllipsis = this.$element.find('.thread-pagination__ellipsis--first');
    this.$lastEllipsis = this.$element.find('.thread-pagination__ellipsis--last');
    this.$previousLink = this.$element.find('.thread-pagination__previous');
    this.$nextLink = this.$element.find('.thread-pagination__next');

    // Total number of items.
    this.itemCount = this.$element.find('.is-last-item a').data('targetItem');

    // Maximum number of adjacent items before & after current item.
    this.maximumRange = options.maximumRange;

    // Minimum number of adjacent items before & after current item.
    this.minimumRange = options.minimumRange;

    // Starting item, if no item specified.
    var defaultItem = Math.ceil(this.itemCount / 2);

    this.currentItem = parseInt(this.getQueryParameter('page'), 10);
    if (this.currentItem === false || isNaN(this.currentItem)) {
      this.currentItem = defaultItem;
    }

    this.goToItem(this.currentItem);

    // Bind each link to point to the appropriate page.
    this.$element.find('.js-thread-pagination-item').click(function () {
      self.goToItem($(this).data('targetItem'));

      // Return false to avoid appending unwanted href "#".
      return false;
    });

    this.$previousLink.on('click', $.proxy(this.goToPreviousItem, this));
    this.$nextLink.on('click', $.proxy(this.goToNextItem, this));
  };

  Pagination.VERSION = '0.0.1';

  Pagination.DEFAULTS = {
    maximumRange: 2,
    minimumRange: 1
  };

  /**
   * Go to the next item.
   *
   * Will do nothing if there are no items to go to.
   *
   * @return {boolean}
   *   This always returns false so it can be used in lieu of anchor tags href.
   */
  Pagination.prototype.goToNextItem = function() {
    if (this.currentItem >= this.itemCount) {
      return false;
    }

    this.goToItem(this.currentItem + 1);

    return false;
  }

  /**
   * Go to the previous page.
   *
   * Will do nothing if there are no pages to go to.
   *
   * @return {boolean}
   *   This always returns false so it can be used in lieu of anchor tags href.
   */
  Pagination.prototype.goToPreviousItem = function() {
    if (this.currentItem <= 1) {
      return false;
    }

    this.goToItem(this.currentItem - 1);

    return false;
  }

  /**
   * Go to a target item.
   *
   * @param {int} targetItem
   *   The destination page.
   */
  Pagination.prototype.goToItem = function(targetItem) {
    var self = this;
    var $currentItem = this.$element.find('.thread-pagination__item--current');

    // If targetItem is invalid or the page is already active, bail early.
    if (typeof targetItem !== 'number' || $currentItem.find('a').data('targetItem') === targetItem) {
      return false;
    }

    // Reset any 'far' links.
    this.$element.find('.thread-pagination__item--far').removeClass('thread-pagination__item--far').addClass('thread-pagination__item');

    // Update the page URL to allow for easy direct linking.
    window.history.replaceState({'page': targetItem}, 'Page ' + targetItem, '?page=' + targetItem);

    // Update the current item.
    $currentItem.removeClass('thread-pagination__item--current').addClass('thread-pagination__item');
    this.$element.find('[data-target-item=' + targetItem + ']').parent('.thread-pagination__item').removeClass('thread-pagination__item').addClass('thread-pagination__item--current');

    // Hide all pages and reveal the adjacent ones.
    this.$element.find('.thread-pagination__item').hide();

    this.getAdjacentItems(targetItem).forEach(function(element) {
      var adjacentItemNumber = self.$element.find(element).find('a').data('targetItem');

      if (self.isFarNeighbour(adjacentItemNumber, targetItem) && adjacentItemNumber > 2 && adjacentItemNumber < self.itemCount - 1) {
        $(element).removeClass('thread-pagination__item').addClass('thread-pagination__item--far');
      }

      $(element).show();
    });

    this.$previousLink.toggleClass('is-disabled', targetItem === 1);
    this.$nextLink.toggleClass('is-disabled', targetItem === this.itemCount);

    // If we need to hide an ellipsis, do so!
    if (this.isNearPaginationStart(targetItem, this.maximumRange + 1)) {
      this.$firstEllipsis.hide();

      if (!this.isNearPaginationEnd(targetItem, this.maximumRange + 1)) {
        this.$lastEllipsis.show();
      }
    } else if (this.isNearPaginationEnd(targetItem, this.maximumRange + 1)) {
      this.$lastEllipsis.hide();
      this.$firstEllipsis.show();
    } else {
      this.$element.find('.thread-pagination__ellipsis--first, .thread-pagination__ellipsis--last').show();
    }

    // First and last pages must always be visible.
    this.$element.find('.is-first-item, .is-last-item').show();

    this.currentItem = targetItem;
  };

  /**
   * Determines if an item is close to the start of the pagination.
   *
   * For a definition of 'close', refer to the optional range variable.
   * This is useful for determining whether the first ellipsis and/or 'Previous' links need to be disabled.
   *
   * @param {int} item
   *   The item to find.
   * @param {int} [range]
   *   (Optional) The maximum distance from the first item.
   * @returns {boolean}
   *   Flag indicating that the given item is close to the start of the pagination.
   */
  Pagination.prototype.isNearPaginationStart = function(item, range) {
    range = range || this.maximumRange;
    return item <= 1 + range;
  };

  /**
   * Determines if an item is close to the end of the pagination.
   *
   * For a definition of 'close', refer to the optional range variable.
   * This is useful for determining whether the last ellipsis and/or 'Next' links need to be disabled.
   *
   * @param {int} item
   *   The item to find.
   * @param {int} [range]
   *   (Optional) The maximum distance from the last page.
   * @returns {boolean}
   *   Flag indicating that the given page is close to the end of the pagination (TRUE) or not (FALSE).
   */
  Pagination.prototype.isNearPaginationEnd = function(item, range) {
    range = range || this.maximumRange;
    return item + range >= this.itemCount;
  };

  /**
   * Determines if an item is 'far' from another item.
   *
   * 'Far' is defined as greater than the minimum range setting.
   *
   * @param {int} neighbouringItem
   *   The item under consideration to determine whether it is 'far'.
   *
   * @param {int} relativeItem
   *   The page that neighbouringItem is to be considered a neighbour of.
   *
   * @return {boolean}
   *   Flag indicating that the neighbouringItem is 'far' (TRUE) or not (FALSE).
   */
  Pagination.prototype.isFarNeighbour = function(neighbouringItem, relativeItem) {
    if (neighbouringItem > relativeItem) {
      return neighbouringItem - relativeItem > this.minimumRange;
    }

    return relativeItem - neighbouringItem > this.minimumRange;
  }

  /**
   * Fetches the links to neighbouring items.
   *
   * @param {int} item
   *   The page that the links are neighbours of.
   *
   * @return {jQuery[]}
   *   A list of jQuery objects referencing the links that neighbour the requested item.
   */
  Pagination.prototype.getAdjacentItems = function(item) {
    var adjacentItems = [];
    var offset;

    if (typeof item !== 'number' || item < 1) {
      return adjacentItems;
    }

    var minimumItem = this.isNearPaginationStart(item) ? 1 : item - this.maximumRange;
    var maximumItem = this.isNearPaginationEnd(item) ? this.itemCount : item + this.maximumRange;

    if (this.itemCount - item <= this.maximumRange) {
      offset = 1 + this.maximumRange - (this.itemCount - item);
      minimumItem = minimumItem - offset < 1 ? 1 : minimumItem - offset;
    } else if (item <= this.maximumRange + 2) {
      // Count the pages between the minimum item & the current item.
      offset = (this.maximumRange + 2) - item;
      maximumItem = maximumItem + offset > this.itemCount ? this.itemCount : maximumItem + offset;
    }

    for (var count = minimumItem; count <= maximumItem; count++) {
      // Only fetch the neighbours; skip the current item.
      if (count === item) {
        continue;
      }

      var adjacentPage = this.$element.find('[data-target-item=' + count + ']').parent('.thread-pagination__item');

      if (adjacentPage.length) {
        adjacentItems.push(adjacentPage);
      }
    }

    return adjacentItems;
  };

  /**
   * Gets the value of a specified parameter available in the URL's query string.
   *
   * @param {string} parameter
   *   The parameter to retrieve the value of.
   * @returns {*}
   *   The value of the parameter, or false if the parameter was not found.
   */
  Pagination.prototype.getQueryParameter = function(parameter) {
    var query = window.location.search.substring(1);
    var params = query.split('&');
    for (var i = 0; i < params.length; i++) {
      var pair = params[i].split('=');
      if (pair[0] == parameter) {
        return pair[1];
      }
    }
    return false;
  };

  /**
   * Plugin definition.
   */
  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('cruk.pagination')
      var options = $.extend({}, Pagination.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('cruk.pagination', (data = new Pagination(this, options)))
    })
  }

  var old = $.fn.Pagination;

  $.fn.pagination = Plugin;
  $.fn.pagination.Constructor = Pagination;

  $.fn.pagination.noConflict = function() {
    $.fn.pagination = old;
    return this;
  };

  $(window).on('load', function () {
    $('.thread-pagination').each(function () {
      var $pagination = $(this);
      Plugin.call($pagination, $pagination.data())
    });
  });
});
